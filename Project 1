import numpy as np
import matplotlib.pyplot as plt
import random
import math

def randomCities(n):
    return np.random.rand(n,2) * 100 #generate random pos (x,y) for n # of cities

def distance(pos1, pos2):
    return math.sqrt(pow(pos2[0] - pos1[0],2) + pow(pos2[1] - pos1[1],2)) #dist between two cities

def totalDistance(n, cities, path):
    total = 0
    for row in range(n-1):
        total += distance(cities[path[row]],cities[path[row + 1]]) #calc dist of complete path
    return total

def randomNeighbor(path):
    new_path = path[:] 
    a, b = random.sample(range(len(path)), 2)
    new_path[a], new_path[b] = new_path[b], new_path[a] #swap two random cities in path
    return new_path

def simulatedAnnealing(cities, initTemp):
    n = len(cities)
    currentPath = list(range(n))
    random.shuffle(currentPath)
    currentCost = totalDistance(n, cities,currentPath)
    bestPath, bestCost = currentPath[:], currentCost
    temperature = initTemp

    for i in range(10000):
        newPath = randomNeighbor(currentPath[:])
        newCost = totalDistance(n,cities,newPath)
        if newCost < currentCost or random.random() < math.exp((currentCost - newCost) / temperature):
            currentPath, currentCost = newPath, newCost

        if currentCost < bestCost:
            bestPath, bestCost = currentPath[:], currentCost

        temperature *= 0.995
        #if temperature < 1e-3:
        #    break

    return bestPath, bestCost

def thresholdAccepting(cities, threshold=10):
    n = len(cities)
    currentPath = list(range(n))
    random.shuffle(currentPath)
    currentCost = totalDistance(n,cities, currentPath)
    bestPath, bestCost = currentPath[:], currentCost
    for i in range(n):
        for j in range(100):
            newPath = randomNeighbor(currentPath[:])
            newCost = totalDistance(n,cities, newPath)
            if (newCost - currentCost) < threshold:
                currentPath, currentCost = newPath, newCost
            if newCost < bestCost:
                bestPath, bestCost = newPath[:], newCost
        threshold *= 0.995
    return bestPath, bestCost

def hillClimbing(cities, iterations=10000):
    n = len(cities)
    currentPath = list(range(n))
    random.shuffle(currentPath)
    currentCost = totalDistance(n,cities, currentPath)
    bestPath, bestCost = currentPath[:], currentCost

    for _ in range(iterations):
        newPath = randomNeighbor(currentPath[:]) 
        newCost = totalDistance(n,cities, newPath)

        if newCost < bestCost:
            bestPath, bestCost = newPath[:], newCost
            currentPath, currentCost = newPath[:], newCost

    return bestPath, bestCost

def plotTsp(cities, path, title):
    plt.figure(figsize=(8, 6))
    ordered_cities = np.array([cities[i] for i in path] + [cities[path[0]]])
    plt.plot(ordered_cities[:, 0], ordered_cities[:, 1], 'o-', markersize=5, label="Path")
    plt.scatter(cities[:, 0], cities[:, 1], c='red', marker='o')
    plt.title(title)
    plt.show()


cityList = randomCities(100)
n = len(cityList)
print(n)
cityDistance = totalDistance(n, cityList, range(n))
print(cityList)
print(cityDistance)

saPath, saCost = simulatedAnnealing(cityList, 1000)
print("simulated annealing done")
hcPath, hcCost = hillClimbing(cityList)
print("hill climbing done")
taPath, taCost = thresholdAccepting(cityList)
print("threshold accepting done")

plotTsp(cityList,saPath, "Simulated Annealing")
plotTsp(cityList,hcPath, "Hill Climbing")
plotTsp(cityList,taPath, "Threshold Accepting")
